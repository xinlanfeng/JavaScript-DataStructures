# 哈希表

### 1. 认识哈希表

- 哈希表通常是基于**数组**实现的，但是相对于数组，它也有很多的**优势**：
  - 哈希表可以提供非常快速的**插入——删除——查找**操作
  - 哈希表进行插入删除操作的时间复杂度为O(1)，只需要几个机器指令即可完成
  - 哈希表的可以很快速的查找到需要的元素，比树还要快，且相对于树来说哈希表的编码更容易
- 哈希表相对于数组的一些**不足**：
  - 哈希表中的数据是**没有顺序**的，不能用一种固定的方式来遍历其中的元素
  - 通常情况下，哈希表中的key是**不允许重复**的，不能用相同的key来保存不同的元素
- **哈希表的结构就是数组**，但是它神奇的地方在于**对下标值的一种变换**，这种变换我们可以称之为**哈希函数**，通过哈希函数可以获取到**HashCode**
- **哈希函数可以让key值与数组的索引值对应起来**
- 这样当想要查找某一个元素时，只需要知道元素的名称（key），就可以快速的通过哈希函数找到这个元素的在数组中的索引值，从而通过索引值很快速的在数组中找到需要的元素



### 2. 哈希表的一些概念

- 哈希化: 将HashCode转化成数组范围内（Length）**下标**的过程

- 哈希函数: 将元素转成HashCode，HashCode哈希化为数组下标的代码实现

- 哈希表: 最终插入数据的这个数组就是一个哈希表

  

### 3. 解决哈希化带来的冲突

- 冲突：元素转化成HashCode，HashCode再哈希化后得到的下标值可能是相同的

- 解决冲突的办法：

  - 链地址法（拉链法）

    数组的每一项中不再存放具体的值，而是存放一个链条（数组或者链表）。链条中存放哈希化后下标值相同的值。需要具体查找某一项时，就根据下标值找到对应的位置，然后进行链条的查找（这里的链条一般而言不会过长）

    注意：使用数组或者链表的线性查找效率都差不多。但如果新插入的数据要放在最前端，则使用链表更好

    ![](https://upload-images.jianshu.io/upload_images/1102036-0abbe32e9a9e5ec8?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

  

  - 开放地址法

    开发地址法的主要工作方式为：**寻找空白的位置**来放置冲突的数据

    ![](https://upload-images.jianshu.io/upload_images/1102036-a7b7cd5bb3a97185?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp)

    探索空白位置的方式有三种：

    - 线性探测：线性的查找空白位置

      - 插入：如果index的位置已经有值了，就从index+1的位置开始，线性查找空白的位置，哪里有空位置就放置在哪里

      - 查找：先判断index的位置的值是否是查询需要的值，如果不是，则从index+1的位置开始线性查找，**直到查询到有空白的位置就停止**（因为要查询的值不可能在这个空位置的后面）

      - 删除：删除和查询类似，也是从index+1开始线性查找，但需要注意的是当需要删除某一项时，不可以将这一下标对应的内容置为null（空位置可能会导致查询时出问题）。所以，删除一项时，通常将这一项进行特殊处理（比如设置为-1），之后看到某一位置为-1时就知道查询时要继续查询，但插入时这个位置可以插入数据

      - 问题：线性探测有一个严重的问题就是**聚集**（一连串的填充单元）。比如想要放置一个数据时，发现一连串连续的位置都不允许放置数据，就需要探测很长的距离。聚集会影响哈希表的性能，无论插入、查询、删除都会影响。

      

    - 二次探测

      - 二次探测在线性探测的基础上进行了优化，主要**优化**的是**探测的步长**

      - 线性探测可以看成是步长为1的探测，比如哈希化后的下标值为x,那么线性探测就是从
        $$
        x+1,x+2,x+3......依次探测
        $$

      - 二次探测，对步长做了优化，比如哈希化后的下标值为x，那么二次探测就是从
        $$
        x+1^2,x+2^2,x+3^2……探测
        $$
        这样就可以**一次性探测比较长的距离**，避免聚集带来的影响

      - 问题：二次探测依然存在问题：**步长不一的聚集**，影响效率

    

    - 再哈希法

      - 二次探测的算法产生的探测序列是固定的: 1, 4, 9, 16, ……

      - 现在需要一种方法: 产生一种**依赖关键字的探测序列**, 而不是每个关键字都一样。那么, 不同的关键字即使映射到相同的数组下标, 也可以使用不同的探测序列

      - 再哈希法的做法就是:**把关键字用另外一个哈希函数, 再做一次哈希化**,用这次哈希化的结果**作为步长**。对于指定的关键字, 步长在整个探测中是不变的, 不过**不同的关键字使用不同的步长**

      - 第二次哈希化需要具备如下特点：

        - 和第一个哈希函数不同

        - 不能输出为0(否则，将没有步长，每次探测都是原地踏步，算法就进入了死循环)

        - 例如计算机专家设计出的一种很好的哈希函数：

          `stepSize = constant - (key % constant)` 

          其中`constant`是质数, 且小于数组的容量。

          例如: `stepSize = 5 - (key % 5)` 满足需求, 并且结果不可能为0



### 4. 哈希化的效率

- 装填因子（loadFactor）：表示当前哈希表中**已经包含的数据项和整个哈希表长度的比值**（已有数据项 / 哈希表长度）
- **开发地址法的装填因子最大为1**，因为它必须找到空白的位置才能放置元素
- **链地址法的装填因子最大可以大于1**，因为链地址法可以无限延伸下去（当然延伸过长则效率变低）
- 各种方法的效率比较参考：[coderwhy的简书：解决哈希化冲突的各种方法的效率的比较](https://www.jianshu.com/p/6e88d63061f2)
- 开放地址法中，二次探测和再哈希法性能相当，都比线性探测的性能略好
- 链地址法（拉链法）的效率相对来说是好于开放地址法的
- 所以在真实的开发中，使用**链地址法**的情况较多
  - 因为链地址法不会因为添加了元素后性能急剧下降
  - Java中的HashMap就是使用的链地址法解决冲突



### 5. 优秀的哈希函数

- 哈希表的主要优点就是它的速度很快。提高速度的一个办法就是让哈希函数中**尽量少的有乘法和除法**，因为它们的性能是比较低的。

- 好的哈希函数应该具备的优点：

  - 快速计算：需要通过快速的计算来获取元素对应的HashCode

    - 原来通过 P<sub>n</sub>(x) = a<sub>n</sub>x<sup>n</sup> + a<sub>n-1</sub>x<sup>n-1</sup> +……+ a<sub>1</sub>x<sup>1</sup> + a<sub>0</sub>x<sup>0</sup> 这个多项式计算HashCode，

      需要 n(n+1)/2 次乘法，n次加法

    - 通过霍纳法则（秦九韶算法）：

      P<sub>n</sub>(x) = a<sub>n</sub>x<sup>n</sup> + a<sub>n-1</sub>x<sup>n-1</sup> +……+ a<sub>1</sub>x<sup>1</sup> + a<sub>0</sub>x<sup>0</sup>  = ((… ((( a<sub>n</sub> x + a<sub>n-1</sub>)x + a<sub>n-2</sub>)x + a<sub>n-3</sub>)x …)x+a<sub>1</sub>)x+a<sub>0</sub>

      变换后，只需要N次乘法，N次加法，时间复杂度从 O(N<sup>2</sup>) 变成了 O(N)

      

  - 均匀分布：好的哈希函数应该尽可能将元素映射到不同的位置，让元素在哈希表中均匀分布

    - 为了让元素在哈希表中均匀分布需要用**质数**表示**哈希表的长度**以及**N次幂的底数**

    - 哈希表的长度使用质数

      - 在链地址法中事实上重要性不是特别明显, 明显的是在开放地址法中的再哈希法中

      - 再哈希法中：

        - 假设表的容量不是质数, 例如: 表长为15(下标值0~14) 。有一个特定关键字映射到0, 步长为5探测序列是0 - 5 - 10 - 0 - 5 - 10, 依次类推, 循环下去。算法只尝试着三个单元, 如果这三个单元已经有了数据, 那么会一直循环下去, 直到程序崩溃
        - 如果容量是一个质数, 比如13. 则探测序列是0 - 5 - 10 - 2 - 7 - 12 - 4 - 9 - 1 - 6 - 11 - 3, 一直这样下去。不仅不会产生循环, 而且可以让数据在哈希表中更加均匀的分布

        

      - 链地址法中哈希表的长度是否为质数没有那么重要, 甚至在Java中故意是2的N次幂

        - Java中的HashMap采用的是链地址法，HashMap的初始长度是16，每次自动扩展，长度必须是2的N次幂。这是为了服务从key映射到index的算法

        - HashMap中为了提高效率, 采用了**与运算**的方式（两个位都为1时，结果才为1）

          HashMap中index的计算公式: **index = HashCode（Key） & （Length - 1）**

        - 但是，JavaScript中进行较大数据的位运算时会出问题, 所以这里的代码实现使用了取余运算

          **取余运算：index = HashCode (key)  %  Length**

          

    - N次幂的底数使用质数为了产生的数据不按照某种规律递增

      - 比如我们这里有一组数据是按照4进行递增的: 0 4 8 12 16, 将其映射到长度为8的哈希表中

        它们的位置是 0 - 4 - 0 - 4 - 0

      - 如果哈希表的长度（比如：8）本身不是质数, 那么数据递增的数量如果可以使用质数, 比如5, 那么 0 5 10 15 20 在哈希表中的位置是  0 - 5 - 2 - 7 - 4，也可以让数据尽量的均匀分布

      - 一个比较常用的N次幂的底数是37

  

- 哈希函数的代码实现

  霍纳法则公式： ((… ((( a<sub>n</sub> x + a<sub>n-1</sub>)x + a<sub>n-2</sub>)x + a<sub>n-3</sub>)x …)x+a<sub>1</sub>)x+a<sub>0</sub>  ， 用37来表示X

  ```javascript
  function hashFunc(str, size) {
      // 1.初始化hashCode的值
      let hashCode = 0;
  
      // 2.霍纳算法, 来计算hashCode的数值
      // 字符串的下标值从左往右数，字符串最左边的字符下标值为0，对应霍纳法则公式中的an
      // 霍纳法则中的x的值设为质数37
      for (let i = 0; i < str.length; i++) {
          hashCode = 37 * hashCode + str.charCodeAt(i);
      }
  
      // 3.取余运算 --- 计算出对应的数组的下标值
      // size表示数组的长度
      return hashCode % size;
  }
  ```




### 6. 哈希表扩容/缩容

- 链地址法的loadFactor(装填因子)可以大于1，哈希表可以无限制的插入新数据

- 但是，随着数据量的增多，当数组的某个位置的链条越来越长时，哈希表的效率就会变低，所以需要在合适的时候对哈希表进行扩容

- 当大量删除了一项数据后，哈希表中的数据量很少，而数组的长度却很大时，会造成浪费，这时需要进行缩容

- 比较常见的情况是**loadFactor>0.75的时候进行扩容**（Java中的HashMap就是这样的）

- **loadFactor<0.25的时候需要减小容量**

- 容量改变后，哈希表中的所有数据项都需要进行修改（重新调用哈希函数来获取对应的位置）

- 前面已经提过，当哈希表的长度是一个质数时，更有利于数据的均匀分布，所以如何在哈希表容量改变时让哈希表的容量一直为质数呢？

  ```javascript
  //质数：只能被1和自己本身整除的数
  //判断一个数是否为质数
  //方式一：效率低
  function isPrime1(num){
      for(let i = 2; i < num; i++){
          if(num % i === 0) return false;
      }
      return true;
  }
  
  //方式二：效率高
  //一个数num如果可以进行因数分解，那么分解后得到的2个数一定是：一个小于等于sqrt(num)，一个大于等于sqrt(num) -- sqrt(num)表示num的平方根
  //所以这里并不需要遍历到num-1才结束，只需要遍历到sqrt(num)就可以了
  function isPrime2(num){
      let temp = parseInt(Math.sqrt(num));
      
      for(let i = 2; i <= temp; i++){
          if( num % i === 0) return false;
      }
      
      return true;
  }
  
  //获取质数，实现哈希表的容量恒为质数
  function getPrime(num){
      while(!isPrime2(num)){
        num++;
      }
      return num;
  }
  ```

  

  